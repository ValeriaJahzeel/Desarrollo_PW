import numpy as np


def imprimir_Matriz(M):
  for i in M:
    for j in i:
      print(j, end=" ")
    print()


M = [[1, 2, 3], [8, 0, 4], [7, 5, 6]] #estado inicial

F = [[1, 2, 3], [8, 0, 4], [7, 6, 5]]  #matris de estado final


def busca_n(M, n):
  coordenadas = [0, 0]
  for i in range(3):
    for j in range(3):
      if (M[i][j] == n):
        coordenadas[0] = i
        coordenadas[1] = j
  return coordenadas


def h(actual, final):
  h_simple = 0
  for i in range(3):
    for j in range(3):
      if (actual[i][j] != final[i][j]):
        h_simple += 1
  return h_simple


def h_manhattan(actual, final):
  h_m = 0
  for i in range(3):
    for j in range(3):
      a = busca_n(actual, actual[i][j])
      b = busca_n(final, actual[i][j])
      h_m += abs(a[0] - b[0])
      h_m += abs(a[1] - b[1])
  return h_m


def mov_val(coordenadas):
  movimientos = [1, 1, 1, 1]
  if (coordenadas[0] - 1 == -1):
    movimientos[1] = 0
  if (coordenadas[1] - 1 == -1):
    movimientos[0] = 0
  if (coordenadas[0] + 1 == 3):
    movimientos[3] = 0
  if (coordenadas[1] + 1 == 3):
    movimientos[2] = 0
  return movimientos


costos = []
i = 0


def minimo(movimientos, cero, M, n):

  if (M == F):
    return 0

#  Nmov=[1,1,1,1]
  imprimir_Matriz(M)
  f1 = f2 = f3 = f4 = 100
  print()
  if (movimientos[0] == 1):  #intercambia las celdas a la izquierda
    M[cero[0]][cero[1]], M[cero[0]][cero[1]-1] = M[cero[0]][cero[1]-1], M[cero[0]][cero[1]]
    imprimir_Matriz(M)
    f1 = n + h(M, F)
    costos.append(f1)
    print(f1)
    M[cero[0]][cero[1] - 1], M[cero[0]][cero[1]] = M[cero[0]][cero[1]], M[cero[0]][cero[1] - 1]

  if (movimientos[1] == 1):  #intercambia las celdas arriba
    M[cero[0]][cero[1]], M[cero[0]-1][cero[1]] = M[cero[0]-1][cero[1]], M[cero[0]][cero[1]]
    imprimir_Matriz(M)
    f2 = n + h(M, F)
    costos.append(f2)
    print(f2)
    M[cero[0] -
      1][cero[1]], M[cero[0]][cero[1]] = M[cero[0]][cero[1]], M[cero[0]-1][cero[1]]

  if (movimientos[2] == 1):  #intercambia las celdas derecha
    M[cero[0]][cero[1]], M[cero[0]][cero[1]+1] = M[cero[0]][cero[1]+1], M[cero[0]][cero[1]]
    imprimir_Matriz(M)
    f3 = n + h(M, F)
    costos.append(f3)
    print(f3)
    M[cero[0]][cero[1] + 1], M[cero[0]][cero[1]] = M[cero[0]][cero[1]], M[cero[0]][cero[1] + 1]

  if (movimientos[3] == 1):  #intercambia las celdas abajo
    M[cero[0]][cero[1]], M[cero[0]+1][cero[1]] = M[cero[0]+1][cero[1]], M[cero[0]][cero[1]]
    imprimir_Matriz(M)
    f4 = n + h(M, F)
    costos.append(f4)
    print(f4)
    M[cero[0]+1][cero[1]], M[cero[0]][cero[1]] = M[cero[0]][cero[1]], M[cero[0]+1][cero[1]]

  minimo = min(f1, f2, f3, f4)
  if (minimo == f1):
    M[cero[0]][cero[1]], M[cero[0]][cero[1]-1] = M[cero[0]][cero[1]-1], M[cero[0]][cero[1]]
  elif (minimo == f2):
    M[cero[0]][cero[1]], M[cero[0]-1][cero[1]] = M[cero[0]-1][cero[1]], M[cero[0]][cero[1]]
  elif (minimo == f3):
    M[cero[0]][cero[1]], M[cero[0]][cero[1]+1] = M[cero[0]][cero[1]+1], M[cero[0]][cero[1]]
  elif (minimo == f4):
    M[cero[0]][cero[1]], M[cero[0]+1][cero[1]] = M[cero[0]+1][cero[1]], M[cero[0]][cero[1]]

  #convertir la matriz M a vector para guardarlo
  estado = np.ravel(M)
  matriz = np.empty((0, 9))
  matriz = np.append(matriz, [estado], axis=0)
  print(matriz)
  return matriz


def ruta():
  while (h(M, F) != 0):  #mientras no sean iguales
    minimo(mov_val(busca_n(M, 0)), busca_n(M, 0), M, 1)


imprimir_Matriz(M)
print("\n")

minimo(mov_val(busca_n(M, 0)), busca_n(M, 0), M, 0)
